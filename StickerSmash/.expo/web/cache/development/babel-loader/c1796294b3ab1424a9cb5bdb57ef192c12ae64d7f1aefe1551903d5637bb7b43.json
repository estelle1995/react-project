{"ast":null,"code":"'use strict';\n\nfunction _createForOfIteratorHelperLoose(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nimport { isJest } from \"./PlatformChecker\";\nimport { runOnUI } from \"./threads\";\nimport { isSharedValue } from \"./isSharedValue\";\nvar IS_JEST = isJest();\nfunction createMapperRegistry() {\n  'worklet';\n\n  var mappers = new Map();\n  var sortedMappers = [];\n  var runRequested = false;\n  var processingMappers = false;\n  function updateMappersOrder() {\n    var pre = new Map();\n    mappers.forEach(function (mapper) {\n      if (mapper.outputs) {\n        for (var _iterator = _createForOfIteratorHelperLoose(mapper.outputs), _step; !(_step = _iterator()).done;) {\n          var output = _step.value;\n          var preMappers = pre.get(output);\n          if (preMappers === undefined) {\n            pre.set(output, [mapper]);\n          } else {\n            preMappers.push(mapper);\n          }\n        }\n      }\n    });\n    var visited = new Set();\n    var newOrder = [];\n    function dfs(mapper) {\n      visited.add(mapper);\n      for (var _iterator2 = _createForOfIteratorHelperLoose(mapper.inputs), _step2; !(_step2 = _iterator2()).done;) {\n        var input = _step2.value;\n        var preMappers = pre.get(input);\n        if (preMappers) {\n          for (var _iterator3 = _createForOfIteratorHelperLoose(preMappers), _step3; !(_step3 = _iterator3()).done;) {\n            var preMapper = _step3.value;\n            if (!visited.has(preMapper)) {\n              dfs(preMapper);\n            }\n          }\n        }\n      }\n      newOrder.push(mapper);\n    }\n    mappers.forEach(function (mapper) {\n      if (!visited.has(mapper)) {\n        dfs(mapper);\n      }\n    });\n    sortedMappers = newOrder;\n  }\n  function mapperRun() {\n    runRequested = false;\n    if (processingMappers) {\n      return;\n    }\n    try {\n      processingMappers = true;\n      if (mappers.size !== sortedMappers.length) {\n        updateMappersOrder();\n      }\n      for (var _iterator4 = _createForOfIteratorHelperLoose(sortedMappers), _step4; !(_step4 = _iterator4()).done;) {\n        var mapper = _step4.value;\n        if (mapper.dirty) {\n          mapper.dirty = false;\n          mapper.worklet();\n        }\n      }\n    } finally {\n      processingMappers = false;\n    }\n  }\n  function maybeRequestUpdates() {\n    if (IS_JEST) {\n      mapperRun();\n    } else if (!runRequested) {\n      if (processingMappers) {\n        requestAnimationFrame(mapperRun);\n      } else {\n        queueMicrotask(mapperRun);\n      }\n      runRequested = true;\n    }\n  }\n  function extractInputs(inputs, resultArray) {\n    if (Array.isArray(inputs)) {\n      for (var _iterator5 = _createForOfIteratorHelperLoose(inputs), _step5; !(_step5 = _iterator5()).done;) {\n        var input = _step5.value;\n        input && extractInputs(input, resultArray);\n      }\n    } else if (isSharedValue(inputs)) {\n      resultArray.push(inputs);\n    } else if (Object.getPrototypeOf(inputs) === Object.prototype) {\n      for (var _i = 0, _Object$values = Object.values(inputs); _i < _Object$values.length; _i++) {\n        var element = _Object$values[_i];\n        element && extractInputs(element, resultArray);\n      }\n    }\n    return resultArray;\n  }\n  return {\n    start: function start(mapperID, worklet, inputs, outputs) {\n      var mapper = {\n        id: mapperID,\n        dirty: true,\n        worklet: worklet,\n        inputs: extractInputs(inputs, []),\n        outputs: outputs\n      };\n      mappers.set(mapper.id, mapper);\n      sortedMappers = [];\n      for (var _iterator6 = _createForOfIteratorHelperLoose(mapper.inputs), _step6; !(_step6 = _iterator6()).done;) {\n        var sv = _step6.value;\n        sv.addListener(mapper.id, function () {\n          mapper.dirty = true;\n          maybeRequestUpdates();\n        });\n      }\n      maybeRequestUpdates();\n    },\n    stop: function stop(mapperID) {\n      var mapper = mappers.get(mapperID);\n      if (mapper) {\n        mappers.delete(mapper.id);\n        sortedMappers = [];\n        for (var _iterator7 = _createForOfIteratorHelperLoose(mapper.inputs), _step7; !(_step7 = _iterator7()).done;) {\n          var sv = _step7.value;\n          sv.removeListener(mapper.id);\n        }\n      }\n    }\n  };\n}\nvar MAPPER_ID = 9999;\nexport function startMapper(worklet) {\n  var inputs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var outputs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var mapperID = MAPPER_ID += 1;\n  runOnUI(function () {\n    var mapperRegistry = global.__mapperRegistry;\n    if (mapperRegistry === undefined) {\n      mapperRegistry = global.__mapperRegistry = createMapperRegistry();\n    }\n    mapperRegistry.start(mapperID, worklet, inputs, outputs);\n  })();\n  return mapperID;\n}\nexport function stopMapper(mapperID) {\n  runOnUI(function () {\n    var mapperRegistry = global.__mapperRegistry;\n    mapperRegistry === null || mapperRegistry === void 0 || mapperRegistry.stop(mapperID);\n  })();\n}","map":{"version":3,"names":["_createForOfIteratorHelperLoose","r","e","t","Symbol","iterator","call","next","bind","Array","isArray","_unsupportedIterableToArray","length","o","done","value","TypeError","a","_arrayLikeToArray","toString","slice","constructor","name","from","test","n","isJest","runOnUI","isSharedValue","IS_JEST","createMapperRegistry","mappers","Map","sortedMappers","runRequested","processingMappers","updateMappersOrder","pre","forEach","mapper","outputs","_iterator","_step","output","preMappers","get","undefined","set","push","visited","Set","newOrder","dfs","add","_iterator2","inputs","_step2","input","_iterator3","_step3","preMapper","has","mapperRun","size","_iterator4","_step4","dirty","worklet","maybeRequestUpdates","requestAnimationFrame","queueMicrotask","extractInputs","resultArray","_iterator5","_step5","Object","getPrototypeOf","prototype","_i","_Object$values","values","element","start","mapperID","id","_iterator6","_step6","sv","addListener","stop","delete","_iterator7","_step7","removeListener","MAPPER_ID","startMapper","arguments","mapperRegistry","global","__mapperRegistry","stopMapper"],"sources":["/Users/xd/Desktop/study/react/react-project/StickerSmash/node_modules/react-native-reanimated/lib/module/reanimated2/mappers.ts"],"sourcesContent":["'use strict';\nimport type {\n  MapperRawInputs,\n  MapperOutputs,\n  SharedValue,\n} from './commonTypes';\nimport { isJest } from './PlatformChecker';\nimport { runOnUI } from './threads';\nimport { isSharedValue } from './isSharedValue';\n\nconst IS_JEST = isJest();\n\ntype MapperExtractedInputs = SharedValue[];\n\ntype Mapper = {\n  id: number;\n  dirty: boolean;\n  worklet: () => void;\n  inputs: MapperExtractedInputs;\n  outputs?: MapperOutputs;\n};\n\nfunction createMapperRegistry() {\n  'worklet';\n  const mappers = new Map<number, Mapper>();\n  let sortedMappers: Mapper[] = [];\n\n  let runRequested = false;\n  let processingMappers = false;\n\n  function updateMappersOrder() {\n    // sort mappers topologically\n    // the algorithm here takes adventage of a fact that the topological order\n    // of a transposed graph is a reverse topological order of the original graph\n    // The graph in our case consists of mappers and an edge between two mappers\n    // A and B exists if there is a shared value that's on A's output lists and on\n    // B's input list.\n    //\n    // We don't need however to calculate that graph as it is easier to work with\n    // the transposed version of it that can be calculated ad-hoc. For the transposed\n    // version to be traversed we use \"pre\" map that maps share value to mappers that\n    // output that shared value. Then we can infer all the outgoing edges for a given\n    // mapper simply by scanning it's input list and checking if any of the shared values\n    // from that list exists in the \"pre\" map. If they do, then we have an edge between\n    // that mapper and the mappers from the \"pre\" list for the given shared value.\n    //\n    // For topological sorting we use a dfs-based approach that requires the graph to\n    // be traversed in dfs order and each node after being processed lands at the\n    // beginning of the topological order list. Since we traverse a transposed graph,\n    // instead of reversing that order we can use a normal array and push processed\n    // mappers to the end. There is no need to reverse that array after we are done.\n    const pre = new Map(); // map from sv -> mapper that outputs that sv\n    mappers.forEach((mapper) => {\n      if (mapper.outputs) {\n        for (const output of mapper.outputs) {\n          const preMappers = pre.get(output);\n          if (preMappers === undefined) {\n            pre.set(output, [mapper]);\n          } else {\n            preMappers.push(mapper);\n          }\n        }\n      }\n    });\n    const visited = new Set();\n    const newOrder: Mapper[] = [];\n    function dfs(mapper: Mapper) {\n      visited.add(mapper);\n      for (const input of mapper.inputs) {\n        const preMappers = pre.get(input);\n        if (preMappers) {\n          for (const preMapper of preMappers) {\n            if (!visited.has(preMapper)) {\n              dfs(preMapper);\n            }\n          }\n        }\n      }\n      newOrder.push(mapper);\n    }\n    mappers.forEach((mapper) => {\n      if (!visited.has(mapper)) {\n        dfs(mapper);\n      }\n    });\n    sortedMappers = newOrder;\n  }\n\n  function mapperRun() {\n    runRequested = false;\n    if (processingMappers) {\n      return;\n    }\n    try {\n      processingMappers = true;\n      if (mappers.size !== sortedMappers.length) {\n        updateMappersOrder();\n      }\n      for (const mapper of sortedMappers) {\n        if (mapper.dirty) {\n          mapper.dirty = false;\n          mapper.worklet();\n        }\n      }\n    } finally {\n      processingMappers = false;\n    }\n  }\n\n  function maybeRequestUpdates() {\n    if (IS_JEST) {\n      // On Jest environment we avoid using queueMicrotask as that'd require test\n      // to advance the clock manually. This on other hand would require tests\n      // to know how many times mappers need to run. As we don't want tests to\n      // make any assumptions on that number it is easier to execute mappers\n      // immediately for testing purposes and only expect test to advance timers\n      // if they want to make any assertions on the effects of animations being run.\n      mapperRun();\n    } else if (!runRequested) {\n      if (processingMappers) {\n        // In general, we should avoid having mappers trigger updates as this may\n        // result in unpredictable behavior. Specifically, the updated value can\n        // be read by mappers that run later in the same frame but previous mappers\n        // would access the old value. Updating mappers during the mapper-run phase\n        // breaks the order in which we should execute the mappers. However, doing\n        // that is still a possibility and there are some instances where people use\n        // the API in that way, hence we need to prevent mapper-run phase falling into\n        // an infinite loop. We do that by detecting when mapper-run is requested while\n        // we are already in mapper-run phase, and in that case we use `requestAnimationFrame`\n        // instead of `queueMicrotask` which will schedule mapper run for the next\n        // frame instead of queuing another set of updates in the same frame.\n        requestAnimationFrame(mapperRun);\n      } else {\n        queueMicrotask(mapperRun);\n      }\n      runRequested = true;\n    }\n  }\n\n  function extractInputs(\n    inputs: unknown,\n    resultArray: MapperExtractedInputs\n  ): MapperExtractedInputs {\n    if (Array.isArray(inputs)) {\n      for (const input of inputs) {\n        input && extractInputs(input, resultArray);\n      }\n    } else if (isSharedValue(inputs)) {\n      resultArray.push(inputs);\n    } else if (Object.getPrototypeOf(inputs) === Object.prototype) {\n      // we only extract inputs recursively from \"plain\" objects here, if object\n      // is of a derivative class (e.g. HostObject on web, or Map) we don't scan\n      // it recursively\n      for (const element of Object.values(inputs as Record<string, unknown>)) {\n        element && extractInputs(element, resultArray);\n      }\n    }\n    return resultArray;\n  }\n\n  return {\n    start: (\n      mapperID: number,\n      worklet: () => void,\n      inputs: MapperRawInputs,\n      outputs?: MapperOutputs\n    ) => {\n      const mapper: Mapper = {\n        id: mapperID,\n        dirty: true,\n        worklet,\n        inputs: extractInputs(inputs, []),\n        outputs,\n      };\n      mappers.set(mapper.id, mapper);\n      sortedMappers = [];\n      for (const sv of mapper.inputs) {\n        sv.addListener(mapper.id, () => {\n          mapper.dirty = true;\n          maybeRequestUpdates();\n        });\n      }\n      maybeRequestUpdates();\n    },\n    stop: (mapperID: number) => {\n      const mapper = mappers.get(mapperID);\n      if (mapper) {\n        mappers.delete(mapper.id);\n        sortedMappers = [];\n        for (const sv of mapper.inputs) {\n          sv.removeListener(mapper.id);\n        }\n      }\n    },\n  };\n}\n\nlet MAPPER_ID = 9999;\n\nexport function startMapper(\n  worklet: () => void,\n  inputs: MapperRawInputs = [],\n  outputs: MapperOutputs = []\n): number {\n  const mapperID = (MAPPER_ID += 1);\n\n  runOnUI(() => {\n    let mapperRegistry = global.__mapperRegistry;\n    if (mapperRegistry === undefined) {\n      mapperRegistry = global.__mapperRegistry = createMapperRegistry();\n    }\n    mapperRegistry.start(mapperID, worklet, inputs, outputs);\n  })();\n\n  return mapperID;\n}\n\nexport function stopMapper(mapperID: number): void {\n  runOnUI(() => {\n    const mapperRegistry = global.__mapperRegistry;\n    mapperRegistry?.stop(mapperID);\n  })();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}